// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"fmt"
	"infinote/db"
	"io"
	"strconv"
)

type CreateNote struct {
	Name string `json:"name"`
	Body string `json:"body"`
}

type CursorInput struct {
	LineNumber int `json:"lineNumber"`
	Column     int `json:"column"`
}

type CursorPlacement struct {
	LineNumber int    `json:"lineNumber"`
	Column     int    `json:"column"`
	UserID     string `json:"userID"`
	UserName   string `json:"userName"`
}

type InsertNote struct {
	Text  string `json:"text"`
	Index int    `json:"index"`
}

type NoteChange struct {
	EventID string       `json:"eventID"`
	NoteID  string       `json:"noteID"`
	Insert  *InsertNote  `json:"insert"`
	Cursor  *CursorInput `json:"cursor"`
}

type NoteEvent struct {
	NoteID   string           `json:"noteID"`
	EventID  string           `json:"eventID"`
	Insert   *TextInsert      `json:"insert"`
	Cursor   *CursorPlacement `json:"cursor"`
	UserID   string           `json:"userID"`
	UserName string           `json:"userName"`
}

type NoteEventResult struct {
	Success bool `json:"success"`
}

type NotesConnection struct {
	TotalCount int          `json:"totalCount"`
	Edges      []*NotesEdge `json:"edges"`
	PageInfo   *PageInfo    `json:"pageInfo"`
}

type NotesEdge struct {
	Cursor string   `json:"cursor"`
	Node   *db.Note `json:"node"`
}

type PageInfo struct {
	StartCursor string `json:"startCursor"`
	EndCursor   string `json:"endCursor"`
}

type RequestToken struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type TextInsert struct {
	Text  string `json:"text"`
	Index int    `json:"index"`
}

type UpdateNote struct {
	ID   string `json:"id"`
	Text string `json:"text"`
}

type Perm string

const (
	PermNoteList         Perm = "NoteList"
	PermNoteCreate       Perm = "NoteCreate"
	PermNoteRead         Perm = "NoteRead"
	PermNoteUpdate       Perm = "NoteUpdate"
	PermNoteArchive      Perm = "NoteArchive"
	PermNoteUnarchive    Perm = "NoteUnarchive"
	PermUserList         Perm = "UserList"
	PermUserCreate       Perm = "UserCreate"
	PermUserRead         Perm = "UserRead"
	PermUserUpdate       Perm = "UserUpdate"
	PermUserArchive      Perm = "UserArchive"
	PermUserUnarchive    Perm = "UserUnarchive"
	PermCompanyList      Perm = "CompanyList"
	PermCompanyCreate    Perm = "CompanyCreate"
	PermCompanyRead      Perm = "CompanyRead"
	PermCompanyUpdate    Perm = "CompanyUpdate"
	PermCompanyArchive   Perm = "CompanyArchive"
	PermCompanyUnarchive Perm = "CompanyUnarchive"
)

var AllPerm = []Perm{
	PermNoteList,
	PermNoteCreate,
	PermNoteRead,
	PermNoteUpdate,
	PermNoteArchive,
	PermNoteUnarchive,
	PermUserList,
	PermUserCreate,
	PermUserRead,
	PermUserUpdate,
	PermUserArchive,
	PermUserUnarchive,
	PermCompanyList,
	PermCompanyCreate,
	PermCompanyRead,
	PermCompanyUpdate,
	PermCompanyArchive,
	PermCompanyUnarchive,
}

func (e Perm) IsValid() bool {
	switch e {
	case PermNoteList, PermNoteCreate, PermNoteRead, PermNoteUpdate, PermNoteArchive, PermNoteUnarchive, PermUserList, PermUserCreate, PermUserRead, PermUserUpdate, PermUserArchive, PermUserUnarchive, PermCompanyList, PermCompanyCreate, PermCompanyRead, PermCompanyUpdate, PermCompanyArchive, PermCompanyUnarchive:
		return true
	}
	return false
}

func (e Perm) String() string {
	return string(e)
}

func (e *Perm) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Perm(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Perm", str)
	}
	return nil
}

func (e Perm) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
